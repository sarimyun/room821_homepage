{"ast":null,"code":"import { Amplify, defaultStorage, Hub } from '@aws-amplify/core';\nimport { isBrowser, assertTokenProviderConfig, assertOAuthConfig, urlSafeEncode, AuthAction, AmplifyUrl, AMPLIFY_SYMBOL, USER_AGENT_HEADER, decodeJWT, urlSafeDecode } from '@aws-amplify/core/internals/utils';\nimport { cacheCognitoTokens } from '../tokenProvider/cacheTokens.mjs';\nimport { cognitoUserPoolsTokenProvider } from '../tokenProvider/index.mjs';\nimport { cognitoHostedUIIdentityProviderMap } from '../types/models.mjs';\nimport { DefaultOAuthStore } from '../utils/signInWithRedirectStore.mjs';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { AuthErrorTypes } from '../../../types/Auth.mjs';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings.mjs';\nimport { authErrorMessages } from '../../../Errors.mjs';\nimport { getAuthUserAgentValue } from '../../../utils/getAuthUserAgentValue.mjs';\nimport { openAuthSession } from '../../../utils/openAuthSession.mjs';\nimport { assertUserNotAuthenticated } from '../utils/signInHelpers.mjs';\nimport { generateCodeVerifier } from '../utils/oauth/generateCodeVerifier.mjs';\nimport { generateState } from '../utils/oauth/generateState.mjs';\nimport { getRedirectUrl } from '../utils/oauth/getRedirectUrl.mjs';\nimport { getCurrentUser } from './getCurrentUser.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Signs in a user with OAuth. Redirects the application to an Identity Provider.\n *\n * @param input - The SignInWithRedirectInput object, if empty it will redirect to Cognito HostedUI\n *\n * @throws AuthTokenConfigException - Thrown when the userpool config is invalid.\n * @throws OAuthNotConfigureException - Thrown when the oauth config is invalid.\n */\nasync function signInWithRedirect(input) {\n  const authConfig = Amplify.getConfig().Auth?.Cognito;\n  assertTokenProviderConfig(authConfig);\n  assertOAuthConfig(authConfig);\n  store.setAuthConfig(authConfig);\n  await assertUserNotAuthenticated();\n  let provider = 'COGNITO'; // Default\n  if (typeof input?.provider === 'string') {\n    provider = cognitoHostedUIIdentityProviderMap[input.provider];\n  } else if (input?.provider?.custom) {\n    provider = input.provider.custom;\n  }\n  return oauthSignIn({\n    oauthConfig: authConfig.loginWith.oauth,\n    clientId: authConfig.userPoolClientId,\n    provider,\n    customState: input?.customState,\n    preferPrivateSession: input?.options?.preferPrivateSession\n  });\n}\nconst store = new DefaultOAuthStore(defaultStorage);\nasync function oauthSignIn({\n  oauthConfig,\n  provider,\n  clientId,\n  customState,\n  preferPrivateSession\n}) {\n  const {\n    domain,\n    redirectSignIn,\n    responseType,\n    scopes\n  } = oauthConfig;\n  const randomState = generateState();\n  /* encodeURIComponent is not URL safe, use urlSafeEncode instead. Cognito\n  single-encodes/decodes url on first sign in and double-encodes/decodes url\n  when user already signed in. Using encodeURIComponent, Base32, Base64 add\n  characters % or = which on further encoding becomes unsafe. '=' create issue\n  for parsing query params.\n  Refer: https://github.com/aws-amplify/amplify-js/issues/5218 */\n  const state = customState ? `${randomState}-${urlSafeEncode(customState)}` : randomState;\n  const {\n    value,\n    method,\n    toCodeChallenge\n  } = generateCodeVerifier(128);\n  store.storeOAuthInFlight(true);\n  store.storeOAuthState(state);\n  store.storePKCE(value);\n  const queryString = Object.entries({\n    redirect_uri: getRedirectUrl(oauthConfig.redirectSignIn),\n    response_type: responseType,\n    client_id: clientId,\n    identity_provider: provider,\n    scope: scopes.join(' '),\n    state,\n    ...(responseType === 'code' && {\n      code_challenge: toCodeChallenge(),\n      code_challenge_method: method\n    })\n  }).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  // TODO(v6): use URL object instead\n  const oAuthUrl = `https://${domain}/oauth2/authorize?${queryString}`;\n  const {\n    type,\n    error,\n    url\n  } = (await openAuthSession(oAuthUrl)) ?? {};\n  if (type === 'success' && url) {\n    // ensure the code exchange completion resolves the signInWithRedirect\n    // returned promise in react-native\n    await handleAuthResponse({\n      currentUrl: url,\n      clientId,\n      domain,\n      redirectUri: redirectSignIn[0],\n      responseType,\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n      preferPrivateSession\n    });\n  }\n  if (type === 'error') {\n    handleFailure(String(error));\n  }\n}\nasync function handleCodeFlow({\n  currentUrl,\n  userAgentValue,\n  clientId,\n  redirectUri,\n  domain,\n  preferPrivateSession\n}) {\n  /* Convert URL into an object with parameters as keys\n  { redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n  const url = new AmplifyUrl(currentUrl);\n  let validatedState;\n  try {\n    validatedState = await validateStateFromURL(url);\n  } catch (err) {\n    invokeAndClearPromise();\n    // clear temp values\n    await store.clearOAuthInflightData();\n    return;\n  }\n  const code = url.searchParams.get('code');\n  if (!code) {\n    await store.clearOAuthData();\n    invokeAndClearPromise();\n    return;\n  }\n  const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n  // TODO(v6): check hub events\n  // dispatchAuthEvent(\n  // \t'codeFlow',\n  // \t{},\n  // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n  // );\n  const codeVerifier = await store.loadPKCE();\n  const oAuthTokenBody = {\n    grant_type: 'authorization_code',\n    code,\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    ...(codeVerifier ? {\n      code_verifier: codeVerifier\n    } : {})\n  };\n  const body = Object.entries(oAuthTokenBody).map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`).join('&');\n  const {\n    access_token,\n    refresh_token,\n    id_token,\n    error,\n    token_type,\n    expires_in\n  } = await (await fetch(oAuthTokenEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      [USER_AGENT_HEADER]: userAgentValue\n    },\n    body\n  })).json();\n  if (error) {\n    invokeAndClearPromise();\n    handleFailure(error);\n  }\n  await store.clearOAuthInflightData();\n  const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    RefreshToken: refresh_token,\n    TokenType: token_type,\n    ExpiresIn: expires_in\n  });\n  return completeFlow({\n    redirectUri,\n    state: validatedState,\n    preferPrivateSession\n  });\n}\nasync function handleImplicitFlow({\n  currentUrl,\n  redirectUri,\n  preferPrivateSession\n}) {\n  // hash is `null` if `#` doesn't exist on URL\n  const url = new AmplifyUrl(currentUrl);\n  const {\n    id_token,\n    access_token,\n    state,\n    token_type,\n    expires_in\n  } = (url.hash ?? '#').substring(1) // Remove # from returned code\n  .split('&').map(pairings => pairings.split('=')).reduce((accum, [k, v]) => ({\n    ...accum,\n    [k]: v\n  }), {\n    id_token: undefined,\n    access_token: undefined,\n    state: undefined,\n    token_type: undefined,\n    expires_in: undefined\n  });\n  if (!access_token) {\n    await store.clearOAuthData();\n    invokeAndClearPromise();\n    return;\n  }\n  try {\n    validateState(state);\n  } catch (error) {\n    invokeAndClearPromise();\n    return;\n  }\n  const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    TokenType: token_type,\n    ExpiresIn: expires_in\n  });\n  return completeFlow({\n    redirectUri,\n    state,\n    preferPrivateSession\n  });\n}\nasync function completeFlow({\n  redirectUri,\n  state,\n  preferPrivateSession\n}) {\n  await store.clearOAuthData();\n  await store.storeOAuthSignIn(true, preferPrivateSession);\n  if (isCustomState(state)) {\n    Hub.dispatch('auth', {\n      event: 'customOAuthState',\n      data: urlSafeDecode(getCustomState(state))\n    }, 'Auth', AMPLIFY_SYMBOL);\n  }\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect'\n  }, 'Auth', AMPLIFY_SYMBOL);\n  Hub.dispatch('auth', {\n    event: 'signedIn',\n    data: await getCurrentUser()\n  }, 'Auth', AMPLIFY_SYMBOL);\n  clearHistory(redirectUri);\n  invokeAndClearPromise();\n}\nasync function handleAuthResponse({\n  currentUrl,\n  userAgentValue,\n  clientId,\n  redirectUri,\n  responseType,\n  domain,\n  preferPrivateSession\n}) {\n  try {\n    const urlParams = new AmplifyUrl(currentUrl);\n    const error = urlParams.searchParams.get('error');\n    const errorMessage = urlParams.searchParams.get('error_description');\n    if (error) {\n      handleFailure(errorMessage);\n    }\n    if (responseType === 'code') {\n      return await handleCodeFlow({\n        currentUrl,\n        userAgentValue,\n        clientId,\n        redirectUri,\n        domain,\n        preferPrivateSession\n      });\n    } else {\n      return await handleImplicitFlow({\n        currentUrl,\n        redirectUri,\n        preferPrivateSession\n      });\n    }\n  } catch (e) {\n    throw e;\n  }\n}\nasync function validateStateFromURL(urlParams) {\n  const returnedState = urlParams.searchParams.get('state');\n  validateState(returnedState);\n  return returnedState;\n}\nfunction validateState(state) {\n  let savedState;\n  store.loadOAuthState().then(resp => {\n    savedState = resp;\n  });\n  // This is because savedState only exists if the flow was initiated by Amplify\n  if (savedState && state && savedState !== state) {\n    throw new AuthError({\n      name: AuthErrorTypes.OAuthSignInError,\n      message: 'An error occurred while validating the state',\n      recoverySuggestion: 'Try to initiate an OAuth flow from Amplify'\n    });\n  }\n}\nfunction handleFailure(errorMessage) {\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect_failure'\n  }, 'Auth', AMPLIFY_SYMBOL);\n  throw new AuthError({\n    message: errorMessage ?? '',\n    name: AuthErrorCodes.OAuthSignInError,\n    recoverySuggestion: authErrorMessages.oauthSignInError.log\n  });\n}\nasync function parseRedirectURL() {\n  const authConfig = Amplify.getConfig().Auth?.Cognito;\n  try {\n    assertTokenProviderConfig(authConfig);\n    store.setAuthConfig(authConfig);\n  } catch (_err) {\n    // Token provider not configure nothing to do\n    return;\n  }\n  // No OAuth inflight doesnt need to parse the url\n  if (!(await store.loadOAuthInFlight())) {\n    return;\n  }\n  try {\n    assertOAuthConfig(authConfig);\n  } catch (err) {\n    // TODO(v6): this should warn you have signInWithRedirect but is not configured\n    return;\n  }\n  try {\n    const currentUrl = window.location.href;\n    const {\n      loginWith,\n      userPoolClientId\n    } = authConfig;\n    const {\n      domain,\n      redirectSignIn,\n      responseType\n    } = loginWith.oauth;\n    handleAuthResponse({\n      currentUrl,\n      clientId: userPoolClientId,\n      domain,\n      redirectUri: redirectSignIn[0],\n      responseType,\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect)\n    });\n  } catch (err) {\n    // is ok if there is not OAuthConfig\n  }\n}\nfunction urlListener() {\n  // Listen configure to parse url\n  parseRedirectURL();\n  Hub.listen('core', capsule => {\n    if (capsule.payload.event === 'configure') {\n      parseRedirectURL();\n    }\n  });\n}\nisBrowser() && urlListener();\n// This has a reference for listeners that requires to be notified, TokenOrchestrator use this for load tokens\nlet inflightPromiseResolvers = [];\nconst invokeAndClearPromise = () => {\n  for (const promiseResolver of inflightPromiseResolvers) {\n    promiseResolver();\n  }\n  inflightPromiseResolvers = [];\n};\nisBrowser() && cognitoUserPoolsTokenProvider.setWaitForInflightOAuth(() => new Promise(async (res, _rej) => {\n  if (!(await store.loadOAuthInFlight())) {\n    res();\n  } else {\n    inflightPromiseResolvers.push(res);\n  }\n  return;\n}));\nfunction clearHistory(redirectUri) {\n  if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n    window.history.replaceState({}, '', redirectUri);\n  }\n}\nfunction isCustomState(state) {\n  return /-/.test(state);\n}\nfunction getCustomState(state) {\n  return state.split('-').splice(1).join('-');\n}\nexport { oauthSignIn, signInWithRedirect, store };","map":{"version":3,"names":["signInWithRedirect","input","authConfig","Amplify","getConfig","Auth","Cognito","assertTokenProviderConfig","assertOAuthConfig","store","setAuthConfig","assertUserNotAuthenticated","provider","cognitoHostedUIIdentityProviderMap","custom","oauthSignIn","oauthConfig","loginWith","oauth","clientId","userPoolClientId","customState","preferPrivateSession","options","DefaultOAuthStore","defaultStorage","domain","redirectSignIn","responseType","scopes","randomState","generateState","state","urlSafeEncode","value","method","toCodeChallenge","generateCodeVerifier","storeOAuthInFlight","storeOAuthState","storePKCE","queryString","Object","entries","redirect_uri","getRedirectUrl","response_type","client_id","identity_provider","scope","join","code_challenge","code_challenge_method","map","k","v","encodeURIComponent","oAuthUrl","type","error","url","openAuthSession","handleAuthResponse","currentUrl","redirectUri","userAgentValue","getAuthUserAgentValue","AuthAction","SignInWithRedirect","handleFailure","String","handleCodeFlow","AmplifyUrl","validatedState","validateStateFromURL","err","invokeAndClearPromise","clearOAuthInflightData","code","searchParams","get","clearOAuthData","oAuthTokenEndpoint","codeVerifier","loadPKCE","oAuthTokenBody","grant_type","code_verifier","body","access_token","refresh_token","id_token","token_type","expires_in","fetch","headers","USER_AGENT_HEADER","json","username","decodeJWT","payload","cacheCognitoTokens","AccessToken","IdToken","RefreshToken","TokenType","ExpiresIn","completeFlow","handleImplicitFlow","hash","substring","split","pairings","reduce","accum","undefined","validateState","storeOAuthSignIn","isCustomState","Hub","dispatch","event","data","urlSafeDecode","getCustomState","AMPLIFY_SYMBOL","getCurrentUser","clearHistory","urlParams","errorMessage","e","returnedState","savedState","loadOAuthState","then","resp","AuthError","name","AuthErrorTypes","OAuthSignInError","message","recoverySuggestion","AuthErrorCodes","authErrorMessages","oauthSignInError","log","parseRedirectURL","_err","loadOAuthInFlight","window","location","href","urlListener","listen","capsule","isBrowser","inflightPromiseResolvers","promiseResolver","cognitoUserPoolsTokenProvider","setWaitForInflightOAuth","Promise","res","_rej","push","history","replaceState","test","splice"],"sources":["/Users/sarimyun/react-native-app/room821_homepage/room821_homepage/node_modules/@aws-amplify/auth/src/providers/cognito/apis/signInWithRedirect.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify, Hub, defaultStorage } from '@aws-amplify/core';\nimport { AuthAction, AMPLIFY_SYMBOL, assertOAuthConfig, assertTokenProviderConfig, isBrowser, urlSafeEncode, USER_AGENT_HEADER, urlSafeDecode, decodeJWT, AmplifyUrl, } from '@aws-amplify/core/internals/utils';\nimport { cacheCognitoTokens } from '../tokenProvider/cacheTokens';\nimport { cognitoUserPoolsTokenProvider } from '../tokenProvider';\nimport { cognitoHostedUIIdentityProviderMap } from '../types/models';\nimport { DefaultOAuthStore } from '../utils/signInWithRedirectStore';\nimport { AuthError } from '../../../errors/AuthError';\nimport { AuthErrorTypes } from '../../../types/Auth';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings';\nimport { authErrorMessages } from '../../../Errors';\nimport { getAuthUserAgentValue, openAuthSession } from '../../../utils';\nimport { assertUserNotAuthenticated } from '../utils/signInHelpers';\nimport { generateCodeVerifier, generateState } from '../utils/oauth';\nimport { getCurrentUser } from './getCurrentUser';\nimport { getRedirectUrl } from '../utils/oauth/getRedirectUrl';\n/**\n * Signs in a user with OAuth. Redirects the application to an Identity Provider.\n *\n * @param input - The SignInWithRedirectInput object, if empty it will redirect to Cognito HostedUI\n *\n * @throws AuthTokenConfigException - Thrown when the userpool config is invalid.\n * @throws OAuthNotConfigureException - Thrown when the oauth config is invalid.\n */\nexport async function signInWithRedirect(input) {\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    assertTokenProviderConfig(authConfig);\n    assertOAuthConfig(authConfig);\n    store.setAuthConfig(authConfig);\n    await assertUserNotAuthenticated();\n    let provider = 'COGNITO'; // Default\n    if (typeof input?.provider === 'string') {\n        provider = cognitoHostedUIIdentityProviderMap[input.provider];\n    }\n    else if (input?.provider?.custom) {\n        provider = input.provider.custom;\n    }\n    return oauthSignIn({\n        oauthConfig: authConfig.loginWith.oauth,\n        clientId: authConfig.userPoolClientId,\n        provider,\n        customState: input?.customState,\n        preferPrivateSession: input?.options?.preferPrivateSession,\n    });\n}\nexport const store = new DefaultOAuthStore(defaultStorage);\nexport async function oauthSignIn({ oauthConfig, provider, clientId, customState, preferPrivateSession, }) {\n    const { domain, redirectSignIn, responseType, scopes } = oauthConfig;\n    const randomState = generateState();\n    /* encodeURIComponent is not URL safe, use urlSafeEncode instead. Cognito\n    single-encodes/decodes url on first sign in and double-encodes/decodes url\n    when user already signed in. Using encodeURIComponent, Base32, Base64 add\n    characters % or = which on further encoding becomes unsafe. '=' create issue\n    for parsing query params.\n    Refer: https://github.com/aws-amplify/amplify-js/issues/5218 */\n    const state = customState\n        ? `${randomState}-${urlSafeEncode(customState)}`\n        : randomState;\n    const { value, method, toCodeChallenge } = generateCodeVerifier(128);\n    store.storeOAuthInFlight(true);\n    store.storeOAuthState(state);\n    store.storePKCE(value);\n    const queryString = Object.entries({\n        redirect_uri: getRedirectUrl(oauthConfig.redirectSignIn),\n        response_type: responseType,\n        client_id: clientId,\n        identity_provider: provider,\n        scope: scopes.join(' '),\n        state,\n        ...(responseType === 'code' && {\n            code_challenge: toCodeChallenge(),\n            code_challenge_method: method,\n        }),\n    })\n        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n        .join('&');\n    // TODO(v6): use URL object instead\n    const oAuthUrl = `https://${domain}/oauth2/authorize?${queryString}`;\n    const { type, error, url } = (await openAuthSession(oAuthUrl, redirectSignIn, preferPrivateSession)) ??\n        {};\n    if (type === 'success' && url) {\n        // ensure the code exchange completion resolves the signInWithRedirect\n        // returned promise in react-native\n        await handleAuthResponse({\n            currentUrl: url,\n            clientId,\n            domain,\n            redirectUri: redirectSignIn[0],\n            responseType,\n            userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n            preferPrivateSession,\n        });\n    }\n    if (type === 'error') {\n        handleFailure(String(error));\n    }\n}\nasync function handleCodeFlow({ currentUrl, userAgentValue, clientId, redirectUri, domain, preferPrivateSession, }) {\n    /* Convert URL into an object with parameters as keys\n{ redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n    const url = new AmplifyUrl(currentUrl);\n    let validatedState;\n    try {\n        validatedState = await validateStateFromURL(url);\n    }\n    catch (err) {\n        invokeAndClearPromise();\n        // clear temp values\n        await store.clearOAuthInflightData();\n        return;\n    }\n    const code = url.searchParams.get('code');\n    if (!code) {\n        await store.clearOAuthData();\n        invokeAndClearPromise();\n        return;\n    }\n    const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n    // TODO(v6): check hub events\n    // dispatchAuthEvent(\n    // \t'codeFlow',\n    // \t{},\n    // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n    // );\n    const codeVerifier = await store.loadPKCE();\n    const oAuthTokenBody = {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        redirect_uri: redirectUri,\n        ...(codeVerifier ? { code_verifier: codeVerifier } : {}),\n    };\n    const body = Object.entries(oAuthTokenBody)\n        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n        .join('&');\n    const { access_token, refresh_token, id_token, error, token_type, expires_in, } = await (await fetch(oAuthTokenEndpoint, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            [USER_AGENT_HEADER]: userAgentValue,\n        },\n        body,\n    })).json();\n    if (error) {\n        invokeAndClearPromise();\n        handleFailure(error);\n    }\n    await store.clearOAuthInflightData();\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    await cacheCognitoTokens({\n        username,\n        AccessToken: access_token,\n        IdToken: id_token,\n        RefreshToken: refresh_token,\n        TokenType: token_type,\n        ExpiresIn: expires_in,\n    });\n    return completeFlow({\n        redirectUri,\n        state: validatedState,\n        preferPrivateSession,\n    });\n}\nasync function handleImplicitFlow({ currentUrl, redirectUri, preferPrivateSession, }) {\n    // hash is `null` if `#` doesn't exist on URL\n    const url = new AmplifyUrl(currentUrl);\n    const { id_token, access_token, state, token_type, expires_in } = (url.hash ?? '#')\n        .substring(1) // Remove # from returned code\n        .split('&')\n        .map(pairings => pairings.split('='))\n        .reduce((accum, [k, v]) => ({ ...accum, [k]: v }), {\n        id_token: undefined,\n        access_token: undefined,\n        state: undefined,\n        token_type: undefined,\n        expires_in: undefined,\n    });\n    if (!access_token) {\n        await store.clearOAuthData();\n        invokeAndClearPromise();\n        return;\n    }\n    try {\n        validateState(state);\n    }\n    catch (error) {\n        invokeAndClearPromise();\n        return;\n    }\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    await cacheCognitoTokens({\n        username,\n        AccessToken: access_token,\n        IdToken: id_token,\n        TokenType: token_type,\n        ExpiresIn: expires_in,\n    });\n    return completeFlow({ redirectUri, state, preferPrivateSession });\n}\nasync function completeFlow({ redirectUri, state, preferPrivateSession, }) {\n    await store.clearOAuthData();\n    await store.storeOAuthSignIn(true, preferPrivateSession);\n    if (isCustomState(state)) {\n        Hub.dispatch('auth', {\n            event: 'customOAuthState',\n            data: urlSafeDecode(getCustomState(state)),\n        }, 'Auth', AMPLIFY_SYMBOL);\n    }\n    Hub.dispatch('auth', { event: 'signInWithRedirect' }, 'Auth', AMPLIFY_SYMBOL);\n    Hub.dispatch('auth', { event: 'signedIn', data: await getCurrentUser() }, 'Auth', AMPLIFY_SYMBOL);\n    clearHistory(redirectUri);\n    invokeAndClearPromise();\n}\nasync function handleAuthResponse({ currentUrl, userAgentValue, clientId, redirectUri, responseType, domain, preferPrivateSession, }) {\n    try {\n        const urlParams = new AmplifyUrl(currentUrl);\n        const error = urlParams.searchParams.get('error');\n        const errorMessage = urlParams.searchParams.get('error_description');\n        if (error) {\n            handleFailure(errorMessage);\n        }\n        if (responseType === 'code') {\n            return await handleCodeFlow({\n                currentUrl,\n                userAgentValue,\n                clientId,\n                redirectUri,\n                domain,\n                preferPrivateSession,\n            });\n        }\n        else {\n            return await handleImplicitFlow({\n                currentUrl,\n                redirectUri,\n                preferPrivateSession,\n            });\n        }\n    }\n    catch (e) {\n        throw e;\n    }\n}\nasync function validateStateFromURL(urlParams) {\n    if (!urlParams) {\n    }\n    const returnedState = urlParams.searchParams.get('state');\n    validateState(returnedState);\n    return returnedState;\n}\nfunction validateState(state) {\n    let savedState;\n    store.loadOAuthState().then(resp => {\n        savedState = resp;\n    });\n    // This is because savedState only exists if the flow was initiated by Amplify\n    if (savedState && state && savedState !== state) {\n        throw new AuthError({\n            name: AuthErrorTypes.OAuthSignInError,\n            message: 'An error occurred while validating the state',\n            recoverySuggestion: 'Try to initiate an OAuth flow from Amplify',\n        });\n    }\n}\nfunction handleFailure(errorMessage) {\n    Hub.dispatch('auth', { event: 'signInWithRedirect_failure' }, 'Auth', AMPLIFY_SYMBOL);\n    throw new AuthError({\n        message: errorMessage ?? '',\n        name: AuthErrorCodes.OAuthSignInError,\n        recoverySuggestion: authErrorMessages.oauthSignInError.log,\n    });\n}\nasync function parseRedirectURL() {\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    try {\n        assertTokenProviderConfig(authConfig);\n        store.setAuthConfig(authConfig);\n    }\n    catch (_err) {\n        // Token provider not configure nothing to do\n        return;\n    }\n    // No OAuth inflight doesnt need to parse the url\n    if (!(await store.loadOAuthInFlight())) {\n        return;\n    }\n    try {\n        assertOAuthConfig(authConfig);\n    }\n    catch (err) {\n        // TODO(v6): this should warn you have signInWithRedirect but is not configured\n        return;\n    }\n    try {\n        const currentUrl = window.location.href;\n        const { loginWith, userPoolClientId } = authConfig;\n        const { domain, redirectSignIn, responseType } = loginWith.oauth;\n        handleAuthResponse({\n            currentUrl,\n            clientId: userPoolClientId,\n            domain,\n            redirectUri: redirectSignIn[0],\n            responseType,\n            userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n        });\n    }\n    catch (err) {\n        // is ok if there is not OAuthConfig\n    }\n}\nfunction urlListener() {\n    // Listen configure to parse url\n    parseRedirectURL();\n    Hub.listen('core', capsule => {\n        if (capsule.payload.event === 'configure') {\n            parseRedirectURL();\n        }\n    });\n}\nisBrowser() && urlListener();\n// This has a reference for listeners that requires to be notified, TokenOrchestrator use this for load tokens\nlet inflightPromiseResolvers = [];\nconst invokeAndClearPromise = () => {\n    for (const promiseResolver of inflightPromiseResolvers) {\n        promiseResolver();\n    }\n    inflightPromiseResolvers = [];\n};\nisBrowser() &&\n    cognitoUserPoolsTokenProvider.setWaitForInflightOAuth(() => new Promise(async (res, _rej) => {\n        if (!(await store.loadOAuthInFlight())) {\n            res();\n        }\n        else {\n            inflightPromiseResolvers.push(res);\n        }\n        return;\n    }));\nfunction clearHistory(redirectUri) {\n    if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n        window.history.replaceState({}, '', redirectUri);\n    }\n}\nfunction isCustomState(state) {\n    return /-/.test(state);\n}\nfunction getCustomState(state) {\n    return state.split('-').splice(1).join('-');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}