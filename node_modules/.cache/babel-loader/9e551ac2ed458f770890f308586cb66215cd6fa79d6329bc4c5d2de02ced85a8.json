{"ast":null,"code":"import { ConsoleLogger } from '../Logger/ConsoleLogger.mjs';\nimport { defaultConfig, currentSizeKey } from './constants.mjs';\nimport { getCurrentSizeKey, getCurrentTime, getByteLength } from './utils/cacheHelpers.mjs';\nimport { assert, CacheErrorCode } from './utils/errorHelpers.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nclass StorageCacheCommon {\n  /**\n   * Initialize the cache\n   *\n   * @param config - Custom configuration for this instance.\n   */\n  constructor(_ref) {\n    let {\n      config,\n      keyValueStorage\n    } = _ref;\n    this.config = {\n      ...defaultConfig,\n      ...config\n    };\n    this.keyValueStorage = keyValueStorage;\n    this.sanitizeConfig();\n  }\n  getModuleName() {\n    return 'Cache';\n  }\n  /**\n   * Set custom configuration for the cache instance.\n   *\n   * @param config - customized configuration (without keyPrefix, which can't be changed)\n   *\n   * @return - the current configuration\n   */\n  configure(config) {\n    if (config) {\n      if (config.keyPrefix) {\n        logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n      }\n      this.config = {\n        ...this.config,\n        ...config\n      };\n    }\n    this.sanitizeConfig();\n    return this.config;\n  }\n  /**\n   * return the current size of the cache\n   * @return {Promise}\n   */\n  async getCurrentCacheSize() {\n    let size = await this.getStorage().getItem(getCurrentSizeKey(this.config.keyPrefix));\n    if (!size) {\n      await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), '0');\n      size = '0';\n    }\n    return Number(size);\n  }\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   *\n   * @return {Promise}\n   */\n  async setItem(key, value, options) {\n    logger.debug(\"Set item: key is \".concat(key, \", value is \").concat(value, \" with options: \").concat(options));\n    if (!key || key === currentSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or reserved key: '\".concat(currentSizeKey, \"'\"));\n      return;\n    }\n    if (typeof value === 'undefined') {\n      logger.warn(\"The value of item should not be undefined!\");\n      return;\n    }\n    const cacheItemOptions = {\n      priority: (options === null || options === void 0 ? void 0 : options.priority) !== undefined ? options.priority : this.config.defaultPriority,\n      expires: (options === null || options === void 0 ? void 0 : options.expires) !== undefined ? options.expires : this.config.defaultTTL + getCurrentTime()\n    };\n    if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n      logger.warn(\"Invalid parameter: priority due to out or range. It should be within 1 and 5.\");\n      return;\n    }\n    const prefixedKey = \"\".concat(this.config.keyPrefix).concat(key);\n    const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n    // check whether this item is too big;\n    if (item.byteSize > this.config.itemMaxSize) {\n      logger.warn(\"Item with key: \".concat(key, \" you are trying to put into is too big!\"));\n      return;\n    }\n    try {\n      // first look into the storage, if it exists, delete it.\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n      // check whether the cache is full\n      if (await this.isCacheFull(item.byteSize)) {\n        const validKeys = await this.clearInvalidAndGetRemainingKeys();\n        if (await this.isCacheFull(item.byteSize)) {\n          const sizeToPop = await this.sizeToPop(item.byteSize);\n          await this.popOutItems(validKeys, sizeToPop);\n        }\n      }\n      // put item in the cache\n      return this.setCacheItem(prefixedKey, item);\n    } catch (e) {\n      logger.warn(\"setItem failed! \".concat(e));\n    }\n  }\n  /**\n   * Get item from cache. It will return null if item doesn’t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with AsyncStorage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return {Promise} - return a promise resolves to be the value of the item\n   */\n  async getItem(key, options) {\n    logger.debug(\"Get item: key is \".concat(key, \" with options \").concat(options));\n    let cached;\n    if (!key || key === currentSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or reserved key: '\".concat(currentSizeKey, \"'\"));\n      return null;\n    }\n    const prefixedKey = \"\".concat(this.config.keyPrefix).concat(key);\n    try {\n      cached = await this.getStorage().getItem(prefixedKey);\n      if (cached != null) {\n        if (await this.isExpired(prefixedKey)) {\n          // if expired, remove that item and return null\n          await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n        } else {\n          // if not expired, update its visitedTime and return the value\n          const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n          return item.data;\n        }\n      }\n      if (options !== null && options !== void 0 && options.callback) {\n        const val = options.callback();\n        if (val !== null) {\n          await this.setItem(key, val, options);\n        }\n        return val;\n      }\n      return null;\n    } catch (e) {\n      logger.warn(\"getItem failed! \".concat(e));\n      return null;\n    }\n  }\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with AsyncStorage\n   * @param {String} key - the key of the item\n   * @return {Promise}\n   */\n  async removeItem(key) {\n    logger.debug(\"Remove item: key is \".concat(key));\n    if (!key || key === currentSizeKey) {\n      logger.warn(\"Invalid key: should not be empty or reserved key: '\".concat(currentSizeKey, \"'\"));\n      return;\n    }\n    const prefixedKey = \"\".concat(this.config.keyPrefix).concat(key);\n    try {\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n    } catch (e) {\n      logger.warn(\"removeItem failed! \".concat(e));\n    }\n  }\n  /**\n   * Return all the keys owned by this cache.\n   * Will return an empty array if error occurred.\n   *\n   * @return {Promise}\n   */\n  async getAllKeys() {\n    try {\n      return await this.getAllCacheKeys();\n    } catch (e) {\n      logger.warn(\"getAllkeys failed! \".concat(e));\n      return [];\n    }\n  }\n  getStorage() {\n    return this.keyValueStorage;\n  }\n  /**\n   * check whether item is expired\n   *\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  async isExpired(key) {\n    const text = await this.getStorage().getItem(key);\n    assert(text !== null, CacheErrorCode.NoCacheItem, \"Key: \".concat(key));\n    const item = JSON.parse(text);\n    if (getCurrentTime() >= item.expires) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * delete item from cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  async removeCacheItem(prefixedKey, size) {\n    const item = await this.getStorage().getItem(prefixedKey);\n    assert(item !== null, CacheErrorCode.NoCacheItem, \"Key: \".concat(prefixedKey));\n    const itemSize = size !== null && size !== void 0 ? size : JSON.parse(item).byteSize;\n    // first try to update the current size of the cache\n    await this.decreaseCurrentSizeInBytes(itemSize);\n    // try to remove the item from cache\n    try {\n      await this.getStorage().removeItem(prefixedKey);\n    } catch (removeItemError) {\n      // if some error happened, we need to rollback the current size\n      await this.increaseCurrentSizeInBytes(itemSize);\n      logger.error(\"Failed to remove item: \".concat(removeItemError));\n    }\n  }\n  /**\n   * produce a JSON object with meta-data and data value\n   * @param value - the value of the item\n   * @param options - optional, the specified meta-data\n   *\n   * @return - the item which has the meta-data and the value\n   */\n  fillCacheItem(key, value, options) {\n    var _options$priority, _options$expires;\n    const item = {\n      key,\n      data: value,\n      timestamp: getCurrentTime(),\n      visitedTime: getCurrentTime(),\n      priority: (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : 0,\n      expires: (_options$expires = options.expires) !== null && _options$expires !== void 0 ? _options$expires : 0,\n      type: typeof value,\n      byteSize: 0\n    };\n    // calculate byte size\n    item.byteSize = getByteLength(JSON.stringify(item));\n    // re-calculate using cache item with updated byteSize property\n    item.byteSize = getByteLength(JSON.stringify(item));\n    return item;\n  }\n  sanitizeConfig() {\n    if (this.config.itemMaxSize > this.config.capacityInBytes) {\n      logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n      this.config.itemMaxSize = defaultConfig.itemMaxSize;\n    }\n    if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n      logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n      this.config.defaultPriority = defaultConfig.defaultPriority;\n    }\n    if (Number(this.config.warningThreshold) > 1 || Number(this.config.warningThreshold) < 0) {\n      logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n      this.config.warningThreshold = defaultConfig.warningThreshold;\n    }\n    // Set 5MB limit\n    const cacheLimit = 5 * 1024 * 1024;\n    if (this.config.capacityInBytes > cacheLimit) {\n      logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n      this.config.capacityInBytes = defaultConfig.capacityInBytes;\n    }\n  }\n  /**\n   * increase current size of the cache\n   *\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  async increaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size + amount).toString());\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  async decreaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size - amount).toString());\n  }\n  /**\n   * update the visited time if item has been visited\n   *\n   * @param item - the item which need to be updated\n   * @param prefixedKey - the key of the item\n   *\n   * @return the updated item\n   */\n  async updateVisitedTime(item, prefixedKey) {\n    item.visitedTime = getCurrentTime();\n    await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    return item;\n  }\n  /**\n   * put item into cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  async setCacheItem(prefixedKey, item) {\n    // first try to update the current size of the cache.\n    await this.increaseCurrentSizeInBytes(item.byteSize);\n    // try to add the item into cache\n    try {\n      await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    } catch (setItemErr) {\n      // if some error happened, we need to rollback the current size\n      await this.decreaseCurrentSizeInBytes(item.byteSize);\n      logger.error(\"Failed to set item \".concat(setItemErr));\n    }\n  }\n  /**\n   * total space needed when poping out items\n   *\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  async sizeToPop(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n    const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n    return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n  }\n  /**\n   * see whether cache is full\n   *\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  async isCacheFull(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    return itemSize + cur > this.config.capacityInBytes;\n  }\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  async popOutItems(keys, sizeToPop) {\n    const items = [];\n    let remainedSize = sizeToPop;\n    for (let i = 0; i < keys.length; i += 1) {\n      const val = await this.getStorage().getItem(keys[i]);\n      if (val != null) {\n        const item = JSON.parse(val);\n        items.push(item);\n      }\n    }\n    // first compare priority\n    // then compare visited time\n    items.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      } else {\n        if (a.visitedTime < b.visitedTime) {\n          return -1;\n        } else return 1;\n      }\n    });\n    for (let i = 0; i < items.length; i += 1) {\n      // pop out items until we have enough room for new item\n      await this.removeCacheItem(items[i].key, items[i].byteSize);\n      remainedSize -= items[i].byteSize;\n      if (remainedSize <= 0) {\n        return;\n      }\n    }\n  }\n  /**\n   * Scan the storage and combine the following operations for efficiency\n   *   1. Clear out all expired keys owned by this cache, not including the size key.\n   *   2. Return the remaining keys.\n   *\n   * @return The remaining valid keys\n   */\n  async clearInvalidAndGetRemainingKeys() {\n    const remainingKeys = [];\n    const keys = await this.getAllCacheKeys({\n      omitSizeKey: true\n    });\n    for (const key of keys) {\n      if (await this.isExpired(key)) {\n        await this.removeCacheItem(key);\n      } else {\n        remainingKeys.push(key);\n      }\n    }\n    return remainingKeys;\n  }\n  /**\n   * clear the entire cache\n   * The cache will abort and output a warning if error occurs\n   * @return {Promise}\n   */\n  async clear() {\n    logger.debug(\"Clear Cache\");\n    try {\n      const keys = await this.getAllKeys();\n      for (const key of keys) {\n        await this.getStorage().removeItem(key);\n      }\n    } catch (e) {\n      logger.warn(\"clear failed! \".concat(e));\n    }\n  }\n}\nexport { StorageCacheCommon };","map":{"version":3,"names":["logger","ConsoleLogger","StorageCacheCommon","constructor","_ref","config","keyValueStorage","defaultConfig","sanitizeConfig","getModuleName","configure","keyPrefix","warn","getCurrentCacheSize","size","getStorage","getItem","getCurrentSizeKey","setItem","Number","key","value","options","debug","concat","currentSizeKey","cacheItemOptions","priority","undefined","defaultPriority","expires","defaultTTL","getCurrentTime","prefixedKey","item","fillCacheItem","byteSize","itemMaxSize","val","removeCacheItem","JSON","parse","isCacheFull","validKeys","clearInvalidAndGetRemainingKeys","sizeToPop","popOutItems","setCacheItem","e","cached","isExpired","updateVisitedTime","data","callback","removeItem","getAllKeys","getAllCacheKeys","text","assert","CacheErrorCode","NoCacheItem","itemSize","decreaseCurrentSizeInBytes","removeItemError","increaseCurrentSizeInBytes","error","_options$priority","_options$expires","timestamp","visitedTime","type","getByteLength","stringify","capacityInBytes","warningThreshold","cacheLimit","amount","toString","setItemErr","cur","spaceItemNeed","cacheThresholdSpace","keys","items","remainedSize","i","length","push","sort","a","b","remainingKeys","omitSizeKey","clear"],"sources":["/Users/sarimyun/react-native-app/room821_homepage/room821_homepage/node_modules/@aws-amplify/core/src/Cache/StorageCacheCommon.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ConsoleLogger } from '../Logger';\nimport { currentSizeKey, defaultConfig } from './constants';\nimport { getCurrentSizeKey, getCurrentTime, getByteLength } from './utils';\nimport { assert, CacheErrorCode } from './utils/errorHelpers';\nconst logger = new ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nexport class StorageCacheCommon {\n    /**\n     * Initialize the cache\n     *\n     * @param config - Custom configuration for this instance.\n     */\n    constructor({ config, keyValueStorage, }) {\n        this.config = {\n            ...defaultConfig,\n            ...config,\n        };\n        this.keyValueStorage = keyValueStorage;\n        this.sanitizeConfig();\n    }\n    getModuleName() {\n        return 'Cache';\n    }\n    /**\n     * Set custom configuration for the cache instance.\n     *\n     * @param config - customized configuration (without keyPrefix, which can't be changed)\n     *\n     * @return - the current configuration\n     */\n    configure(config) {\n        if (config) {\n            if (config.keyPrefix) {\n                logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n            }\n            this.config = {\n                ...this.config,\n                ...config,\n            };\n        }\n        this.sanitizeConfig();\n        return this.config;\n    }\n    /**\n     * return the current size of the cache\n     * @return {Promise}\n     */\n    async getCurrentCacheSize() {\n        let size = await this.getStorage().getItem(getCurrentSizeKey(this.config.keyPrefix));\n        if (!size) {\n            await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), '0');\n            size = '0';\n        }\n        return Number(size);\n    }\n    /**\n     * Set item into cache. You can put number, string, boolean or object.\n     * The cache will first check whether has the same key.\n     * If it has, it will delete the old item and then put the new item in\n     * The cache will pop out items if it is full\n     * You can specify the cache item options. The cache will abort and output a warning:\n     * If the key is invalid\n     * If the size of the item exceeds itemMaxSize.\n     * If the value is undefined\n     * If incorrect cache item configuration\n     * If error happened with browser storage\n     *\n     * @param {String} key - the key of the item\n     * @param {Object} value - the value of the item\n     * @param {Object} [options] - optional, the specified meta-data\n     *\n     * @return {Promise}\n     */\n    async setItem(key, value, options) {\n        logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n        if (!key || key === currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n            return;\n        }\n        if (typeof value === 'undefined') {\n            logger.warn(`The value of item should not be undefined!`);\n            return;\n        }\n        const cacheItemOptions = {\n            priority: options?.priority !== undefined\n                ? options.priority\n                : this.config.defaultPriority,\n            expires: options?.expires !== undefined\n                ? options.expires\n                : this.config.defaultTTL + getCurrentTime(),\n        };\n        if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n            logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n            return;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n        // check whether this item is too big;\n        if (item.byteSize > this.config.itemMaxSize) {\n            logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n            return;\n        }\n        try {\n            // first look into the storage, if it exists, delete it.\n            const val = await this.getStorage().getItem(prefixedKey);\n            if (val) {\n                await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n            }\n            // check whether the cache is full\n            if (await this.isCacheFull(item.byteSize)) {\n                const validKeys = await this.clearInvalidAndGetRemainingKeys();\n                if (await this.isCacheFull(item.byteSize)) {\n                    const sizeToPop = await this.sizeToPop(item.byteSize);\n                    await this.popOutItems(validKeys, sizeToPop);\n                }\n            }\n            // put item in the cache\n            return this.setCacheItem(prefixedKey, item);\n        }\n        catch (e) {\n            logger.warn(`setItem failed! ${e}`);\n        }\n    }\n    /**\n     * Get item from cache. It will return null if item doesn’t exist or it has been expired.\n     * If you specified callback function in the options,\n     * then the function will be executed if no such item in the cache\n     * and finally put the return value into cache.\n     * Please make sure the callback function will return the value you want to put into the cache.\n     * The cache will abort output a warning:\n     * If the key is invalid\n     * If error happened with AsyncStorage\n     *\n     * @param {String} key - the key of the item\n     * @param {Object} [options] - the options of callback function\n     *\n     * @return {Promise} - return a promise resolves to be the value of the item\n     */\n    async getItem(key, options) {\n        logger.debug(`Get item: key is ${key} with options ${options}`);\n        let cached;\n        if (!key || key === currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n            return null;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        try {\n            cached = await this.getStorage().getItem(prefixedKey);\n            if (cached != null) {\n                if (await this.isExpired(prefixedKey)) {\n                    // if expired, remove that item and return null\n                    await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n                }\n                else {\n                    // if not expired, update its visitedTime and return the value\n                    const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n                    return item.data;\n                }\n            }\n            if (options?.callback) {\n                const val = options.callback();\n                if (val !== null) {\n                    await this.setItem(key, val, options);\n                }\n                return val;\n            }\n            return null;\n        }\n        catch (e) {\n            logger.warn(`getItem failed! ${e}`);\n            return null;\n        }\n    }\n    /**\n     * remove item from the cache\n     * The cache will abort output a warning:\n     * If error happened with AsyncStorage\n     * @param {String} key - the key of the item\n     * @return {Promise}\n     */\n    async removeItem(key) {\n        logger.debug(`Remove item: key is ${key}`);\n        if (!key || key === currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${currentSizeKey}'`);\n            return;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        try {\n            const val = await this.getStorage().getItem(prefixedKey);\n            if (val) {\n                await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n            }\n        }\n        catch (e) {\n            logger.warn(`removeItem failed! ${e}`);\n        }\n    }\n    /**\n     * Return all the keys owned by this cache.\n     * Will return an empty array if error occurred.\n     *\n     * @return {Promise}\n     */\n    async getAllKeys() {\n        try {\n            return await this.getAllCacheKeys();\n        }\n        catch (e) {\n            logger.warn(`getAllkeys failed! ${e}`);\n            return [];\n        }\n    }\n    getStorage() {\n        return this.keyValueStorage;\n    }\n    /**\n     * check whether item is expired\n     *\n     * @param key - the key of the item\n     *\n     * @return true if the item is expired.\n     */\n    async isExpired(key) {\n        const text = await this.getStorage().getItem(key);\n        assert(text !== null, CacheErrorCode.NoCacheItem, `Key: ${key}`);\n        const item = JSON.parse(text);\n        if (getCurrentTime() >= item.expires) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * delete item from cache\n     *\n     * @param prefixedKey - the key of the item\n     * @param size - optional, the byte size of the item\n     */\n    async removeCacheItem(prefixedKey, size) {\n        const item = await this.getStorage().getItem(prefixedKey);\n        assert(item !== null, CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n        const itemSize = size ?? JSON.parse(item).byteSize;\n        // first try to update the current size of the cache\n        await this.decreaseCurrentSizeInBytes(itemSize);\n        // try to remove the item from cache\n        try {\n            await this.getStorage().removeItem(prefixedKey);\n        }\n        catch (removeItemError) {\n            // if some error happened, we need to rollback the current size\n            await this.increaseCurrentSizeInBytes(itemSize);\n            logger.error(`Failed to remove item: ${removeItemError}`);\n        }\n    }\n    /**\n     * produce a JSON object with meta-data and data value\n     * @param value - the value of the item\n     * @param options - optional, the specified meta-data\n     *\n     * @return - the item which has the meta-data and the value\n     */\n    fillCacheItem(key, value, options) {\n        const item = {\n            key,\n            data: value,\n            timestamp: getCurrentTime(),\n            visitedTime: getCurrentTime(),\n            priority: options.priority ?? 0,\n            expires: options.expires ?? 0,\n            type: typeof value,\n            byteSize: 0,\n        };\n        // calculate byte size\n        item.byteSize = getByteLength(JSON.stringify(item));\n        // re-calculate using cache item with updated byteSize property\n        item.byteSize = getByteLength(JSON.stringify(item));\n        return item;\n    }\n    sanitizeConfig() {\n        if (this.config.itemMaxSize > this.config.capacityInBytes) {\n            logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n            this.config.itemMaxSize = defaultConfig.itemMaxSize;\n        }\n        if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n            logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n            this.config.defaultPriority = defaultConfig.defaultPriority;\n        }\n        if (Number(this.config.warningThreshold) > 1 ||\n            Number(this.config.warningThreshold) < 0) {\n            logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n            this.config.warningThreshold = defaultConfig.warningThreshold;\n        }\n        // Set 5MB limit\n        const cacheLimit = 5 * 1024 * 1024;\n        if (this.config.capacityInBytes > cacheLimit) {\n            logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n            this.config.capacityInBytes = defaultConfig.capacityInBytes;\n        }\n    }\n    /**\n     * increase current size of the cache\n     *\n     * @param amount - the amount of the cache szie which need to be increased\n     */\n    async increaseCurrentSizeInBytes(amount) {\n        const size = await this.getCurrentCacheSize();\n        await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size + amount).toString());\n    }\n    /**\n     * decrease current size of the cache\n     *\n     * @param amount - the amount of the cache size which needs to be decreased\n     */\n    async decreaseCurrentSizeInBytes(amount) {\n        const size = await this.getCurrentCacheSize();\n        await this.getStorage().setItem(getCurrentSizeKey(this.config.keyPrefix), (size - amount).toString());\n    }\n    /**\n     * update the visited time if item has been visited\n     *\n     * @param item - the item which need to be updated\n     * @param prefixedKey - the key of the item\n     *\n     * @return the updated item\n     */\n    async updateVisitedTime(item, prefixedKey) {\n        item.visitedTime = getCurrentTime();\n        await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n        return item;\n    }\n    /**\n     * put item into cache\n     *\n     * @param prefixedKey - the key of the item\n     * @param itemData - the value of the item\n     * @param itemSizeInBytes - the byte size of the item\n     */\n    async setCacheItem(prefixedKey, item) {\n        // first try to update the current size of the cache.\n        await this.increaseCurrentSizeInBytes(item.byteSize);\n        // try to add the item into cache\n        try {\n            await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n        }\n        catch (setItemErr) {\n            // if some error happened, we need to rollback the current size\n            await this.decreaseCurrentSizeInBytes(item.byteSize);\n            logger.error(`Failed to set item ${setItemErr}`);\n        }\n    }\n    /**\n     * total space needed when poping out items\n     *\n     * @param itemSize\n     *\n     * @return total space needed\n     */\n    async sizeToPop(itemSize) {\n        const cur = await this.getCurrentCacheSize();\n        const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n        const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n        return spaceItemNeed > cacheThresholdSpace\n            ? spaceItemNeed\n            : cacheThresholdSpace;\n    }\n    /**\n     * see whether cache is full\n     *\n     * @param itemSize\n     *\n     * @return true if cache is full\n     */\n    async isCacheFull(itemSize) {\n        const cur = await this.getCurrentCacheSize();\n        return itemSize + cur > this.config.capacityInBytes;\n    }\n    /**\n     * get all the items we have, sort them by their priority,\n     * if priority is same, sort them by their last visited time\n     * pop out items from the low priority (5 is the lowest)\n     * @private\n     * @param keys - all the keys in this cache\n     * @param sizeToPop - the total size of the items which needed to be poped out\n     */\n    async popOutItems(keys, sizeToPop) {\n        const items = [];\n        let remainedSize = sizeToPop;\n        for (let i = 0; i < keys.length; i += 1) {\n            const val = await this.getStorage().getItem(keys[i]);\n            if (val != null) {\n                const item = JSON.parse(val);\n                items.push(item);\n            }\n        }\n        // first compare priority\n        // then compare visited time\n        items.sort((a, b) => {\n            if (a.priority > b.priority) {\n                return -1;\n            }\n            else if (a.priority < b.priority) {\n                return 1;\n            }\n            else {\n                if (a.visitedTime < b.visitedTime) {\n                    return -1;\n                }\n                else\n                    return 1;\n            }\n        });\n        for (let i = 0; i < items.length; i += 1) {\n            // pop out items until we have enough room for new item\n            await this.removeCacheItem(items[i].key, items[i].byteSize);\n            remainedSize -= items[i].byteSize;\n            if (remainedSize <= 0) {\n                return;\n            }\n        }\n    }\n    /**\n     * Scan the storage and combine the following operations for efficiency\n     *   1. Clear out all expired keys owned by this cache, not including the size key.\n     *   2. Return the remaining keys.\n     *\n     * @return The remaining valid keys\n     */\n    async clearInvalidAndGetRemainingKeys() {\n        const remainingKeys = [];\n        const keys = await this.getAllCacheKeys({\n            omitSizeKey: true,\n        });\n        for (const key of keys) {\n            if (await this.isExpired(key)) {\n                await this.removeCacheItem(key);\n            }\n            else {\n                remainingKeys.push(key);\n            }\n        }\n        return remainingKeys;\n    }\n    /**\n     * clear the entire cache\n     * The cache will abort and output a warning if error occurs\n     * @return {Promise}\n     */\n    async clear() {\n        logger.debug(`Clear Cache`);\n        try {\n            const keys = await this.getAllKeys();\n            for (const key of keys) {\n                await this.getStorage().removeItem(key);\n            }\n        }\n        catch (e) {\n            logger.warn(`clear failed! ${e}`);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}