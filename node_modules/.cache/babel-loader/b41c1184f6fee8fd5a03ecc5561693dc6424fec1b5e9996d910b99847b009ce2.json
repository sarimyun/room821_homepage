{"ast":null,"code":"import { Amplify, defaultStorage, Hub } from '@aws-amplify/core';\nimport { isBrowser, assertTokenProviderConfig, assertOAuthConfig, urlSafeEncode, AuthAction, AmplifyUrl, AMPLIFY_SYMBOL, USER_AGENT_HEADER, decodeJWT, urlSafeDecode } from '@aws-amplify/core/internals/utils';\nimport { cacheCognitoTokens } from '../tokenProvider/cacheTokens.mjs';\nimport { cognitoUserPoolsTokenProvider } from '../tokenProvider/index.mjs';\nimport { cognitoHostedUIIdentityProviderMap } from '../types/models.mjs';\nimport { DefaultOAuthStore } from '../utils/signInWithRedirectStore.mjs';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { AuthErrorTypes } from '../../../types/Auth.mjs';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings.mjs';\nimport { authErrorMessages } from '../../../Errors.mjs';\nimport { getAuthUserAgentValue } from '../../../utils/getAuthUserAgentValue.mjs';\nimport { openAuthSession } from '../../../utils/openAuthSession.mjs';\nimport { assertUserNotAuthenticated } from '../utils/signInHelpers.mjs';\nimport { generateCodeVerifier } from '../utils/oauth/generateCodeVerifier.mjs';\nimport { generateState } from '../utils/oauth/generateState.mjs';\nimport { getRedirectUrl } from '../utils/oauth/getRedirectUrl.mjs';\nimport { getCurrentUser } from './getCurrentUser.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Signs in a user with OAuth. Redirects the application to an Identity Provider.\n *\n * @param input - The SignInWithRedirectInput object, if empty it will redirect to Cognito HostedUI\n *\n * @throws AuthTokenConfigException - Thrown when the userpool config is invalid.\n * @throws OAuthNotConfigureException - Thrown when the oauth config is invalid.\n */\nasync function signInWithRedirect(input) {\n  var _Amplify$getConfig$Au, _input$provider, _input$options;\n  const authConfig = (_Amplify$getConfig$Au = Amplify.getConfig().Auth) === null || _Amplify$getConfig$Au === void 0 ? void 0 : _Amplify$getConfig$Au.Cognito;\n  assertTokenProviderConfig(authConfig);\n  assertOAuthConfig(authConfig);\n  store.setAuthConfig(authConfig);\n  await assertUserNotAuthenticated();\n  let provider = 'COGNITO'; // Default\n  if (typeof (input === null || input === void 0 ? void 0 : input.provider) === 'string') {\n    provider = cognitoHostedUIIdentityProviderMap[input.provider];\n  } else if (input !== null && input !== void 0 && (_input$provider = input.provider) !== null && _input$provider !== void 0 && _input$provider.custom) {\n    provider = input.provider.custom;\n  }\n  return oauthSignIn({\n    oauthConfig: authConfig.loginWith.oauth,\n    clientId: authConfig.userPoolClientId,\n    provider,\n    customState: input === null || input === void 0 ? void 0 : input.customState,\n    preferPrivateSession: input === null || input === void 0 || (_input$options = input.options) === null || _input$options === void 0 ? void 0 : _input$options.preferPrivateSession\n  });\n}\nconst store = new DefaultOAuthStore(defaultStorage);\nasync function oauthSignIn(_ref) {\n  var _await$openAuthSessio;\n  let {\n    oauthConfig,\n    provider,\n    clientId,\n    customState,\n    preferPrivateSession\n  } = _ref;\n  const {\n    domain,\n    redirectSignIn,\n    responseType,\n    scopes\n  } = oauthConfig;\n  const randomState = generateState();\n  /* encodeURIComponent is not URL safe, use urlSafeEncode instead. Cognito\n  single-encodes/decodes url on first sign in and double-encodes/decodes url\n  when user already signed in. Using encodeURIComponent, Base32, Base64 add\n  characters % or = which on further encoding becomes unsafe. '=' create issue\n  for parsing query params.\n  Refer: https://github.com/aws-amplify/amplify-js/issues/5218 */\n  const state = customState ? \"\".concat(randomState, \"-\").concat(urlSafeEncode(customState)) : randomState;\n  const {\n    value,\n    method,\n    toCodeChallenge\n  } = generateCodeVerifier(128);\n  store.storeOAuthInFlight(true);\n  store.storeOAuthState(state);\n  store.storePKCE(value);\n  const queryString = Object.entries({\n    redirect_uri: getRedirectUrl(oauthConfig.redirectSignIn),\n    response_type: responseType,\n    client_id: clientId,\n    identity_provider: provider,\n    scope: scopes.join(' '),\n    state,\n    ...(responseType === 'code' && {\n      code_challenge: toCodeChallenge(),\n      code_challenge_method: method\n    })\n  }).map(_ref2 => {\n    let [k, v] = _ref2;\n    return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(v));\n  }).join('&');\n  // TODO(v6): use URL object instead\n  const oAuthUrl = \"https://\".concat(domain, \"/oauth2/authorize?\").concat(queryString);\n  const {\n    type,\n    error,\n    url\n  } = (_await$openAuthSessio = await openAuthSession(oAuthUrl)) !== null && _await$openAuthSessio !== void 0 ? _await$openAuthSessio : {};\n  if (type === 'success' && url) {\n    // ensure the code exchange completion resolves the signInWithRedirect\n    // returned promise in react-native\n    await handleAuthResponse({\n      currentUrl: url,\n      clientId,\n      domain,\n      redirectUri: redirectSignIn[0],\n      responseType,\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n      preferPrivateSession\n    });\n  }\n  if (type === 'error') {\n    handleFailure(String(error));\n  }\n}\nasync function handleCodeFlow(_ref3) {\n  var _ref5;\n  let {\n    currentUrl,\n    userAgentValue,\n    clientId,\n    redirectUri,\n    domain,\n    preferPrivateSession\n  } = _ref3;\n  /* Convert URL into an object with parameters as keys\n  { redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n  const url = new AmplifyUrl(currentUrl);\n  let validatedState;\n  try {\n    validatedState = await validateStateFromURL(url);\n  } catch (err) {\n    invokeAndClearPromise();\n    // clear temp values\n    await store.clearOAuthInflightData();\n    return;\n  }\n  const code = url.searchParams.get('code');\n  if (!code) {\n    await store.clearOAuthData();\n    invokeAndClearPromise();\n    return;\n  }\n  const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n  // TODO(v6): check hub events\n  // dispatchAuthEvent(\n  // \t'codeFlow',\n  // \t{},\n  // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n  // );\n  const codeVerifier = await store.loadPKCE();\n  const oAuthTokenBody = {\n    grant_type: 'authorization_code',\n    code,\n    client_id: clientId,\n    redirect_uri: redirectUri,\n    ...(codeVerifier ? {\n      code_verifier: codeVerifier\n    } : {})\n  };\n  const body = Object.entries(oAuthTokenBody).map(_ref4 => {\n    let [k, v] = _ref4;\n    return \"\".concat(encodeURIComponent(k), \"=\").concat(encodeURIComponent(v));\n  }).join('&');\n  const {\n    access_token,\n    refresh_token,\n    id_token,\n    error,\n    token_type,\n    expires_in\n  } = await (await fetch(oAuthTokenEndpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n      [USER_AGENT_HEADER]: userAgentValue\n    },\n    body\n  })).json();\n  if (error) {\n    invokeAndClearPromise();\n    handleFailure(error);\n  }\n  await store.clearOAuthInflightData();\n  const username = (_ref5 = access_token && decodeJWT(access_token).payload.username) !== null && _ref5 !== void 0 ? _ref5 : 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    RefreshToken: refresh_token,\n    TokenType: token_type,\n    ExpiresIn: expires_in\n  });\n  return completeFlow({\n    redirectUri,\n    state: validatedState,\n    preferPrivateSession\n  });\n}\nasync function handleImplicitFlow(_ref6) {\n  var _url$hash, _ref8;\n  let {\n    currentUrl,\n    redirectUri,\n    preferPrivateSession\n  } = _ref6;\n  // hash is `null` if `#` doesn't exist on URL\n  const url = new AmplifyUrl(currentUrl);\n  const {\n    id_token,\n    access_token,\n    state,\n    token_type,\n    expires_in\n  } = ((_url$hash = url.hash) !== null && _url$hash !== void 0 ? _url$hash : '#').substring(1) // Remove # from returned code\n  .split('&').map(pairings => pairings.split('=')).reduce((accum, _ref7) => {\n    let [k, v] = _ref7;\n    return {\n      ...accum,\n      [k]: v\n    };\n  }, {\n    id_token: undefined,\n    access_token: undefined,\n    state: undefined,\n    token_type: undefined,\n    expires_in: undefined\n  });\n  if (!access_token) {\n    await store.clearOAuthData();\n    invokeAndClearPromise();\n    return;\n  }\n  try {\n    validateState(state);\n  } catch (error) {\n    invokeAndClearPromise();\n    return;\n  }\n  const username = (_ref8 = access_token && decodeJWT(access_token).payload.username) !== null && _ref8 !== void 0 ? _ref8 : 'username';\n  await cacheCognitoTokens({\n    username,\n    AccessToken: access_token,\n    IdToken: id_token,\n    TokenType: token_type,\n    ExpiresIn: expires_in\n  });\n  return completeFlow({\n    redirectUri,\n    state,\n    preferPrivateSession\n  });\n}\nasync function completeFlow(_ref9) {\n  let {\n    redirectUri,\n    state,\n    preferPrivateSession\n  } = _ref9;\n  await store.clearOAuthData();\n  await store.storeOAuthSignIn(true, preferPrivateSession);\n  if (isCustomState(state)) {\n    Hub.dispatch('auth', {\n      event: 'customOAuthState',\n      data: urlSafeDecode(getCustomState(state))\n    }, 'Auth', AMPLIFY_SYMBOL);\n  }\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect'\n  }, 'Auth', AMPLIFY_SYMBOL);\n  Hub.dispatch('auth', {\n    event: 'signedIn',\n    data: await getCurrentUser()\n  }, 'Auth', AMPLIFY_SYMBOL);\n  clearHistory(redirectUri);\n  invokeAndClearPromise();\n}\nasync function handleAuthResponse(_ref10) {\n  let {\n    currentUrl,\n    userAgentValue,\n    clientId,\n    redirectUri,\n    responseType,\n    domain,\n    preferPrivateSession\n  } = _ref10;\n  try {\n    const urlParams = new AmplifyUrl(currentUrl);\n    const error = urlParams.searchParams.get('error');\n    const errorMessage = urlParams.searchParams.get('error_description');\n    if (error) {\n      handleFailure(errorMessage);\n    }\n    if (responseType === 'code') {\n      return await handleCodeFlow({\n        currentUrl,\n        userAgentValue,\n        clientId,\n        redirectUri,\n        domain,\n        preferPrivateSession\n      });\n    } else {\n      return await handleImplicitFlow({\n        currentUrl,\n        redirectUri,\n        preferPrivateSession\n      });\n    }\n  } catch (e) {\n    throw e;\n  }\n}\nasync function validateStateFromURL(urlParams) {\n  const returnedState = urlParams.searchParams.get('state');\n  validateState(returnedState);\n  return returnedState;\n}\nfunction validateState(state) {\n  let savedState;\n  store.loadOAuthState().then(resp => {\n    savedState = resp;\n  });\n  // This is because savedState only exists if the flow was initiated by Amplify\n  if (savedState && state && savedState !== state) {\n    throw new AuthError({\n      name: AuthErrorTypes.OAuthSignInError,\n      message: 'An error occurred while validating the state',\n      recoverySuggestion: 'Try to initiate an OAuth flow from Amplify'\n    });\n  }\n}\nfunction handleFailure(errorMessage) {\n  Hub.dispatch('auth', {\n    event: 'signInWithRedirect_failure'\n  }, 'Auth', AMPLIFY_SYMBOL);\n  throw new AuthError({\n    message: errorMessage !== null && errorMessage !== void 0 ? errorMessage : '',\n    name: AuthErrorCodes.OAuthSignInError,\n    recoverySuggestion: authErrorMessages.oauthSignInError.log\n  });\n}\nasync function parseRedirectURL() {\n  var _Amplify$getConfig$Au2;\n  const authConfig = (_Amplify$getConfig$Au2 = Amplify.getConfig().Auth) === null || _Amplify$getConfig$Au2 === void 0 ? void 0 : _Amplify$getConfig$Au2.Cognito;\n  try {\n    assertTokenProviderConfig(authConfig);\n    store.setAuthConfig(authConfig);\n  } catch (_err) {\n    // Token provider not configure nothing to do\n    return;\n  }\n  // No OAuth inflight doesnt need to parse the url\n  if (!(await store.loadOAuthInFlight())) {\n    return;\n  }\n  try {\n    assertOAuthConfig(authConfig);\n  } catch (err) {\n    // TODO(v6): this should warn you have signInWithRedirect but is not configured\n    return;\n  }\n  try {\n    const currentUrl = window.location.href;\n    const {\n      loginWith,\n      userPoolClientId\n    } = authConfig;\n    const {\n      domain,\n      redirectSignIn,\n      responseType\n    } = loginWith.oauth;\n    handleAuthResponse({\n      currentUrl,\n      clientId: userPoolClientId,\n      domain,\n      redirectUri: redirectSignIn[0],\n      responseType,\n      userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect)\n    });\n  } catch (err) {\n    // is ok if there is not OAuthConfig\n  }\n}\nfunction urlListener() {\n  // Listen configure to parse url\n  parseRedirectURL();\n  Hub.listen('core', capsule => {\n    if (capsule.payload.event === 'configure') {\n      parseRedirectURL();\n    }\n  });\n}\nisBrowser() && urlListener();\n// This has a reference for listeners that requires to be notified, TokenOrchestrator use this for load tokens\nlet inflightPromiseResolvers = [];\nconst invokeAndClearPromise = () => {\n  for (const promiseResolver of inflightPromiseResolvers) {\n    promiseResolver();\n  }\n  inflightPromiseResolvers = [];\n};\nisBrowser() && cognitoUserPoolsTokenProvider.setWaitForInflightOAuth(() => new Promise(async (res, _rej) => {\n  if (!(await store.loadOAuthInFlight())) {\n    res();\n  } else {\n    inflightPromiseResolvers.push(res);\n  }\n  return;\n}));\nfunction clearHistory(redirectUri) {\n  if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n    window.history.replaceState({}, '', redirectUri);\n  }\n}\nfunction isCustomState(state) {\n  return /-/.test(state);\n}\nfunction getCustomState(state) {\n  return state.split('-').splice(1).join('-');\n}\nexport { oauthSignIn, signInWithRedirect, store };","map":{"version":3,"names":["signInWithRedirect","input","_Amplify$getConfig$Au","_input$provider","_input$options","authConfig","Amplify","getConfig","Auth","Cognito","assertTokenProviderConfig","assertOAuthConfig","store","setAuthConfig","assertUserNotAuthenticated","provider","cognitoHostedUIIdentityProviderMap","custom","oauthSignIn","oauthConfig","loginWith","oauth","clientId","userPoolClientId","customState","preferPrivateSession","options","DefaultOAuthStore","defaultStorage","_ref","_await$openAuthSessio","domain","redirectSignIn","responseType","scopes","randomState","generateState","state","concat","urlSafeEncode","value","method","toCodeChallenge","generateCodeVerifier","storeOAuthInFlight","storeOAuthState","storePKCE","queryString","Object","entries","redirect_uri","getRedirectUrl","response_type","client_id","identity_provider","scope","join","code_challenge","code_challenge_method","map","_ref2","k","v","encodeURIComponent","oAuthUrl","type","error","url","openAuthSession","handleAuthResponse","currentUrl","redirectUri","userAgentValue","getAuthUserAgentValue","AuthAction","SignInWithRedirect","handleFailure","String","handleCodeFlow","_ref3","_ref5","AmplifyUrl","validatedState","validateStateFromURL","err","invokeAndClearPromise","clearOAuthInflightData","code","searchParams","get","clearOAuthData","oAuthTokenEndpoint","codeVerifier","loadPKCE","oAuthTokenBody","grant_type","code_verifier","body","_ref4","access_token","refresh_token","id_token","token_type","expires_in","fetch","headers","USER_AGENT_HEADER","json","username","decodeJWT","payload","cacheCognitoTokens","AccessToken","IdToken","RefreshToken","TokenType","ExpiresIn","completeFlow","handleImplicitFlow","_ref6","_url$hash","_ref8","hash","substring","split","pairings","reduce","accum","_ref7","undefined","validateState","_ref9","storeOAuthSignIn","isCustomState","Hub","dispatch","event","data","urlSafeDecode","getCustomState","AMPLIFY_SYMBOL","getCurrentUser","clearHistory","_ref10","urlParams","errorMessage","e","returnedState","savedState","loadOAuthState","then","resp","AuthError","name","AuthErrorTypes","OAuthSignInError","message","recoverySuggestion","AuthErrorCodes","authErrorMessages","oauthSignInError","log","parseRedirectURL","_Amplify$getConfig$Au2","_err","loadOAuthInFlight","window","location","href","urlListener","listen","capsule","isBrowser","inflightPromiseResolvers","promiseResolver","cognitoUserPoolsTokenProvider","setWaitForInflightOAuth","Promise","res","_rej","push","history","replaceState","test","splice"],"sources":["/Users/sarimyun/react-native-app/room821_homepage/room821_homepage/node_modules/@aws-amplify/auth/src/providers/cognito/apis/signInWithRedirect.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify, Hub, defaultStorage } from '@aws-amplify/core';\nimport { AuthAction, AMPLIFY_SYMBOL, assertOAuthConfig, assertTokenProviderConfig, isBrowser, urlSafeEncode, USER_AGENT_HEADER, urlSafeDecode, decodeJWT, AmplifyUrl, } from '@aws-amplify/core/internals/utils';\nimport { cacheCognitoTokens } from '../tokenProvider/cacheTokens';\nimport { cognitoUserPoolsTokenProvider } from '../tokenProvider';\nimport { cognitoHostedUIIdentityProviderMap } from '../types/models';\nimport { DefaultOAuthStore } from '../utils/signInWithRedirectStore';\nimport { AuthError } from '../../../errors/AuthError';\nimport { AuthErrorTypes } from '../../../types/Auth';\nimport { AuthErrorCodes } from '../../../common/AuthErrorStrings';\nimport { authErrorMessages } from '../../../Errors';\nimport { getAuthUserAgentValue, openAuthSession } from '../../../utils';\nimport { assertUserNotAuthenticated } from '../utils/signInHelpers';\nimport { generateCodeVerifier, generateState } from '../utils/oauth';\nimport { getCurrentUser } from './getCurrentUser';\nimport { getRedirectUrl } from '../utils/oauth/getRedirectUrl';\n/**\n * Signs in a user with OAuth. Redirects the application to an Identity Provider.\n *\n * @param input - The SignInWithRedirectInput object, if empty it will redirect to Cognito HostedUI\n *\n * @throws AuthTokenConfigException - Thrown when the userpool config is invalid.\n * @throws OAuthNotConfigureException - Thrown when the oauth config is invalid.\n */\nexport async function signInWithRedirect(input) {\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    assertTokenProviderConfig(authConfig);\n    assertOAuthConfig(authConfig);\n    store.setAuthConfig(authConfig);\n    await assertUserNotAuthenticated();\n    let provider = 'COGNITO'; // Default\n    if (typeof input?.provider === 'string') {\n        provider = cognitoHostedUIIdentityProviderMap[input.provider];\n    }\n    else if (input?.provider?.custom) {\n        provider = input.provider.custom;\n    }\n    return oauthSignIn({\n        oauthConfig: authConfig.loginWith.oauth,\n        clientId: authConfig.userPoolClientId,\n        provider,\n        customState: input?.customState,\n        preferPrivateSession: input?.options?.preferPrivateSession,\n    });\n}\nexport const store = new DefaultOAuthStore(defaultStorage);\nexport async function oauthSignIn({ oauthConfig, provider, clientId, customState, preferPrivateSession, }) {\n    const { domain, redirectSignIn, responseType, scopes } = oauthConfig;\n    const randomState = generateState();\n    /* encodeURIComponent is not URL safe, use urlSafeEncode instead. Cognito\n    single-encodes/decodes url on first sign in and double-encodes/decodes url\n    when user already signed in. Using encodeURIComponent, Base32, Base64 add\n    characters % or = which on further encoding becomes unsafe. '=' create issue\n    for parsing query params.\n    Refer: https://github.com/aws-amplify/amplify-js/issues/5218 */\n    const state = customState\n        ? `${randomState}-${urlSafeEncode(customState)}`\n        : randomState;\n    const { value, method, toCodeChallenge } = generateCodeVerifier(128);\n    store.storeOAuthInFlight(true);\n    store.storeOAuthState(state);\n    store.storePKCE(value);\n    const queryString = Object.entries({\n        redirect_uri: getRedirectUrl(oauthConfig.redirectSignIn),\n        response_type: responseType,\n        client_id: clientId,\n        identity_provider: provider,\n        scope: scopes.join(' '),\n        state,\n        ...(responseType === 'code' && {\n            code_challenge: toCodeChallenge(),\n            code_challenge_method: method,\n        }),\n    })\n        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n        .join('&');\n    // TODO(v6): use URL object instead\n    const oAuthUrl = `https://${domain}/oauth2/authorize?${queryString}`;\n    const { type, error, url } = (await openAuthSession(oAuthUrl, redirectSignIn, preferPrivateSession)) ??\n        {};\n    if (type === 'success' && url) {\n        // ensure the code exchange completion resolves the signInWithRedirect\n        // returned promise in react-native\n        await handleAuthResponse({\n            currentUrl: url,\n            clientId,\n            domain,\n            redirectUri: redirectSignIn[0],\n            responseType,\n            userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n            preferPrivateSession,\n        });\n    }\n    if (type === 'error') {\n        handleFailure(String(error));\n    }\n}\nasync function handleCodeFlow({ currentUrl, userAgentValue, clientId, redirectUri, domain, preferPrivateSession, }) {\n    /* Convert URL into an object with parameters as keys\n{ redirect_uri: 'http://localhost:3000/', response_type: 'code', ...} */\n    const url = new AmplifyUrl(currentUrl);\n    let validatedState;\n    try {\n        validatedState = await validateStateFromURL(url);\n    }\n    catch (err) {\n        invokeAndClearPromise();\n        // clear temp values\n        await store.clearOAuthInflightData();\n        return;\n    }\n    const code = url.searchParams.get('code');\n    if (!code) {\n        await store.clearOAuthData();\n        invokeAndClearPromise();\n        return;\n    }\n    const oAuthTokenEndpoint = 'https://' + domain + '/oauth2/token';\n    // TODO(v6): check hub events\n    // dispatchAuthEvent(\n    // \t'codeFlow',\n    // \t{},\n    // \t`Retrieving tokens from ${oAuthTokenEndpoint}`\n    // );\n    const codeVerifier = await store.loadPKCE();\n    const oAuthTokenBody = {\n        grant_type: 'authorization_code',\n        code,\n        client_id: clientId,\n        redirect_uri: redirectUri,\n        ...(codeVerifier ? { code_verifier: codeVerifier } : {}),\n    };\n    const body = Object.entries(oAuthTokenBody)\n        .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n        .join('&');\n    const { access_token, refresh_token, id_token, error, token_type, expires_in, } = await (await fetch(oAuthTokenEndpoint, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            [USER_AGENT_HEADER]: userAgentValue,\n        },\n        body,\n    })).json();\n    if (error) {\n        invokeAndClearPromise();\n        handleFailure(error);\n    }\n    await store.clearOAuthInflightData();\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    await cacheCognitoTokens({\n        username,\n        AccessToken: access_token,\n        IdToken: id_token,\n        RefreshToken: refresh_token,\n        TokenType: token_type,\n        ExpiresIn: expires_in,\n    });\n    return completeFlow({\n        redirectUri,\n        state: validatedState,\n        preferPrivateSession,\n    });\n}\nasync function handleImplicitFlow({ currentUrl, redirectUri, preferPrivateSession, }) {\n    // hash is `null` if `#` doesn't exist on URL\n    const url = new AmplifyUrl(currentUrl);\n    const { id_token, access_token, state, token_type, expires_in } = (url.hash ?? '#')\n        .substring(1) // Remove # from returned code\n        .split('&')\n        .map(pairings => pairings.split('='))\n        .reduce((accum, [k, v]) => ({ ...accum, [k]: v }), {\n        id_token: undefined,\n        access_token: undefined,\n        state: undefined,\n        token_type: undefined,\n        expires_in: undefined,\n    });\n    if (!access_token) {\n        await store.clearOAuthData();\n        invokeAndClearPromise();\n        return;\n    }\n    try {\n        validateState(state);\n    }\n    catch (error) {\n        invokeAndClearPromise();\n        return;\n    }\n    const username = (access_token && decodeJWT(access_token).payload.username) ?? 'username';\n    await cacheCognitoTokens({\n        username,\n        AccessToken: access_token,\n        IdToken: id_token,\n        TokenType: token_type,\n        ExpiresIn: expires_in,\n    });\n    return completeFlow({ redirectUri, state, preferPrivateSession });\n}\nasync function completeFlow({ redirectUri, state, preferPrivateSession, }) {\n    await store.clearOAuthData();\n    await store.storeOAuthSignIn(true, preferPrivateSession);\n    if (isCustomState(state)) {\n        Hub.dispatch('auth', {\n            event: 'customOAuthState',\n            data: urlSafeDecode(getCustomState(state)),\n        }, 'Auth', AMPLIFY_SYMBOL);\n    }\n    Hub.dispatch('auth', { event: 'signInWithRedirect' }, 'Auth', AMPLIFY_SYMBOL);\n    Hub.dispatch('auth', { event: 'signedIn', data: await getCurrentUser() }, 'Auth', AMPLIFY_SYMBOL);\n    clearHistory(redirectUri);\n    invokeAndClearPromise();\n}\nasync function handleAuthResponse({ currentUrl, userAgentValue, clientId, redirectUri, responseType, domain, preferPrivateSession, }) {\n    try {\n        const urlParams = new AmplifyUrl(currentUrl);\n        const error = urlParams.searchParams.get('error');\n        const errorMessage = urlParams.searchParams.get('error_description');\n        if (error) {\n            handleFailure(errorMessage);\n        }\n        if (responseType === 'code') {\n            return await handleCodeFlow({\n                currentUrl,\n                userAgentValue,\n                clientId,\n                redirectUri,\n                domain,\n                preferPrivateSession,\n            });\n        }\n        else {\n            return await handleImplicitFlow({\n                currentUrl,\n                redirectUri,\n                preferPrivateSession,\n            });\n        }\n    }\n    catch (e) {\n        throw e;\n    }\n}\nasync function validateStateFromURL(urlParams) {\n    if (!urlParams) {\n    }\n    const returnedState = urlParams.searchParams.get('state');\n    validateState(returnedState);\n    return returnedState;\n}\nfunction validateState(state) {\n    let savedState;\n    store.loadOAuthState().then(resp => {\n        savedState = resp;\n    });\n    // This is because savedState only exists if the flow was initiated by Amplify\n    if (savedState && state && savedState !== state) {\n        throw new AuthError({\n            name: AuthErrorTypes.OAuthSignInError,\n            message: 'An error occurred while validating the state',\n            recoverySuggestion: 'Try to initiate an OAuth flow from Amplify',\n        });\n    }\n}\nfunction handleFailure(errorMessage) {\n    Hub.dispatch('auth', { event: 'signInWithRedirect_failure' }, 'Auth', AMPLIFY_SYMBOL);\n    throw new AuthError({\n        message: errorMessage ?? '',\n        name: AuthErrorCodes.OAuthSignInError,\n        recoverySuggestion: authErrorMessages.oauthSignInError.log,\n    });\n}\nasync function parseRedirectURL() {\n    const authConfig = Amplify.getConfig().Auth?.Cognito;\n    try {\n        assertTokenProviderConfig(authConfig);\n        store.setAuthConfig(authConfig);\n    }\n    catch (_err) {\n        // Token provider not configure nothing to do\n        return;\n    }\n    // No OAuth inflight doesnt need to parse the url\n    if (!(await store.loadOAuthInFlight())) {\n        return;\n    }\n    try {\n        assertOAuthConfig(authConfig);\n    }\n    catch (err) {\n        // TODO(v6): this should warn you have signInWithRedirect but is not configured\n        return;\n    }\n    try {\n        const currentUrl = window.location.href;\n        const { loginWith, userPoolClientId } = authConfig;\n        const { domain, redirectSignIn, responseType } = loginWith.oauth;\n        handleAuthResponse({\n            currentUrl,\n            clientId: userPoolClientId,\n            domain,\n            redirectUri: redirectSignIn[0],\n            responseType,\n            userAgentValue: getAuthUserAgentValue(AuthAction.SignInWithRedirect),\n        });\n    }\n    catch (err) {\n        // is ok if there is not OAuthConfig\n    }\n}\nfunction urlListener() {\n    // Listen configure to parse url\n    parseRedirectURL();\n    Hub.listen('core', capsule => {\n        if (capsule.payload.event === 'configure') {\n            parseRedirectURL();\n        }\n    });\n}\nisBrowser() && urlListener();\n// This has a reference for listeners that requires to be notified, TokenOrchestrator use this for load tokens\nlet inflightPromiseResolvers = [];\nconst invokeAndClearPromise = () => {\n    for (const promiseResolver of inflightPromiseResolvers) {\n        promiseResolver();\n    }\n    inflightPromiseResolvers = [];\n};\nisBrowser() &&\n    cognitoUserPoolsTokenProvider.setWaitForInflightOAuth(() => new Promise(async (res, _rej) => {\n        if (!(await store.loadOAuthInFlight())) {\n            res();\n        }\n        else {\n            inflightPromiseResolvers.push(res);\n        }\n        return;\n    }));\nfunction clearHistory(redirectUri) {\n    if (typeof window !== 'undefined' && typeof window.history !== 'undefined') {\n        window.history.replaceState({}, '', redirectUri);\n    }\n}\nfunction isCustomState(state) {\n    return /-/.test(state);\n}\nfunction getCustomState(state) {\n    return state.split('-').splice(1).join('-');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}