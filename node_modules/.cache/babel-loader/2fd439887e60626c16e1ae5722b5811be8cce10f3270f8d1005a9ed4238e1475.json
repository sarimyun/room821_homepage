{"ast":null,"code":"import { Hub } from '@aws-amplify/core';\nimport { assertTokenProviderConfig, isTokenExpired, AMPLIFY_SYMBOL } from '@aws-amplify/core/internals/utils';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError.mjs';\nimport { AuthError } from '../../../errors/AuthError.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nclass TokenOrchestrator {\n  constructor() {\n    this.waitForInflightOAuth = async () => {};\n  }\n  setAuthConfig(authConfig) {\n    this.authConfig = authConfig;\n  }\n  setTokenRefresher(tokenRefresher) {\n    this.tokenRefresher = tokenRefresher;\n  }\n  setAuthTokenStore(tokenStore) {\n    this.tokenStore = tokenStore;\n  }\n  setWaitForInflightOAuth(waitForInflightOAuth) {\n    this.waitForInflightOAuth = waitForInflightOAuth;\n  }\n  getTokenStore() {\n    if (!this.tokenStore) {\n      throw new AuthError({\n        name: 'EmptyTokenStoreException',\n        message: 'TokenStore not set'\n      });\n    }\n    return this.tokenStore;\n  }\n  getTokenRefresher() {\n    if (!this.tokenRefresher) {\n      throw new AuthError({\n        name: 'EmptyTokenRefresherException',\n        message: 'TokenRefresher not set'\n      });\n    }\n    return this.tokenRefresher;\n  }\n  async getTokens(options) {\n    var _tokens, _tokens$idToken$paylo, _tokens$idToken, _tokens$clockDrift, _tokens$accessToken$p, _tokens$accessToken, _tokens$clockDrift2, _tokens2, _tokens3, _tokens4;\n    let tokens;\n    try {\n      var _this$authConfig;\n      assertTokenProviderConfig((_this$authConfig = this.authConfig) === null || _this$authConfig === void 0 ? void 0 : _this$authConfig.Cognito);\n    } catch (_err) {\n      // Token provider not configured\n      return null;\n    }\n    await this.waitForInflightOAuth();\n    tokens = await this.getTokenStore().loadTokens();\n    const username = await this.getTokenStore().getLastAuthUser();\n    if (tokens === null) {\n      return null;\n    }\n    const idTokenExpired = !!((_tokens = tokens) !== null && _tokens !== void 0 && _tokens.idToken) && isTokenExpired({\n      expiresAt: ((_tokens$idToken$paylo = (_tokens$idToken = tokens.idToken) === null || _tokens$idToken === void 0 || (_tokens$idToken = _tokens$idToken.payload) === null || _tokens$idToken === void 0 ? void 0 : _tokens$idToken.exp) !== null && _tokens$idToken$paylo !== void 0 ? _tokens$idToken$paylo : 0) * 1000,\n      clockDrift: (_tokens$clockDrift = tokens.clockDrift) !== null && _tokens$clockDrift !== void 0 ? _tokens$clockDrift : 0\n    });\n    const accessTokenExpired = isTokenExpired({\n      expiresAt: ((_tokens$accessToken$p = (_tokens$accessToken = tokens.accessToken) === null || _tokens$accessToken === void 0 || (_tokens$accessToken = _tokens$accessToken.payload) === null || _tokens$accessToken === void 0 ? void 0 : _tokens$accessToken.exp) !== null && _tokens$accessToken$p !== void 0 ? _tokens$accessToken$p : 0) * 1000,\n      clockDrift: (_tokens$clockDrift2 = tokens.clockDrift) !== null && _tokens$clockDrift2 !== void 0 ? _tokens$clockDrift2 : 0\n    });\n    if (options !== null && options !== void 0 && options.forceRefresh || idTokenExpired || accessTokenExpired) {\n      tokens = await this.refreshTokens({\n        tokens,\n        username\n      });\n      if (tokens === null) {\n        return null;\n      }\n    }\n    return {\n      accessToken: (_tokens2 = tokens) === null || _tokens2 === void 0 ? void 0 : _tokens2.accessToken,\n      idToken: (_tokens3 = tokens) === null || _tokens3 === void 0 ? void 0 : _tokens3.idToken,\n      signInDetails: (_tokens4 = tokens) === null || _tokens4 === void 0 ? void 0 : _tokens4.signInDetails\n    };\n  }\n  async refreshTokens(_ref) {\n    let {\n      tokens,\n      username\n    } = _ref;\n    try {\n      const newTokens = await this.getTokenRefresher()({\n        tokens,\n        authConfig: this.authConfig,\n        username\n      });\n      await this.setTokens({\n        tokens: newTokens\n      });\n      Hub.dispatch('auth', {\n        event: 'tokenRefresh'\n      }, 'Auth', AMPLIFY_SYMBOL);\n      return newTokens;\n    } catch (err) {\n      return this.handleErrors(err);\n    }\n  }\n  handleErrors(err) {\n    assertServiceError(err);\n    if (err.message !== 'Network error') {\n      // TODO(v6): Check errors on client\n      this.clearTokens();\n    }\n    if (err.name.startsWith('NotAuthorizedException')) {\n      return null;\n    } else {\n      Hub.dispatch('auth', {\n        event: 'tokenRefresh_failure'\n      }, 'Auth', AMPLIFY_SYMBOL);\n      throw err;\n    }\n  }\n  async setTokens(_ref2) {\n    let {\n      tokens\n    } = _ref2;\n    return this.getTokenStore().storeTokens(tokens);\n  }\n  async clearTokens() {\n    return this.getTokenStore().clearTokens();\n  }\n  getDeviceMetadata(username) {\n    return this.getTokenStore().getDeviceMetadata(username);\n  }\n  clearDeviceMetadata(username) {\n    return this.getTokenStore().clearDeviceMetadata(username);\n  }\n}\nexport { TokenOrchestrator };","map":{"version":3,"names":["TokenOrchestrator","constructor","waitForInflightOAuth","setAuthConfig","authConfig","setTokenRefresher","tokenRefresher","setAuthTokenStore","tokenStore","setWaitForInflightOAuth","getTokenStore","AuthError","name","message","getTokenRefresher","getTokens","options","_tokens","_tokens$idToken$paylo","_tokens$idToken","_tokens$clockDrift","_tokens$accessToken$p","_tokens$accessToken","_tokens$clockDrift2","_tokens2","_tokens3","_tokens4","tokens","_this$authConfig","assertTokenProviderConfig","Cognito","_err","loadTokens","username","getLastAuthUser","idTokenExpired","idToken","isTokenExpired","expiresAt","payload","exp","clockDrift","accessTokenExpired","accessToken","forceRefresh","refreshTokens","signInDetails","_ref","newTokens","setTokens","Hub","dispatch","event","AMPLIFY_SYMBOL","err","handleErrors","assertServiceError","clearTokens","startsWith","_ref2","storeTokens","getDeviceMetadata","clearDeviceMetadata"],"sources":["/Users/sarimyun/react-native-app/room821_homepage/room821_homepage/node_modules/@aws-amplify/auth/src/providers/cognito/tokenProvider/TokenOrchestrator.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Hub, } from '@aws-amplify/core';\nimport { AMPLIFY_SYMBOL, assertTokenProviderConfig, isTokenExpired, } from '@aws-amplify/core/internals/utils';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError';\nimport { AuthError } from '../../../errors/AuthError';\nexport class TokenOrchestrator {\n    constructor() {\n        this.waitForInflightOAuth = async () => { };\n    }\n    setAuthConfig(authConfig) {\n        this.authConfig = authConfig;\n    }\n    setTokenRefresher(tokenRefresher) {\n        this.tokenRefresher = tokenRefresher;\n    }\n    setAuthTokenStore(tokenStore) {\n        this.tokenStore = tokenStore;\n    }\n    setWaitForInflightOAuth(waitForInflightOAuth) {\n        this.waitForInflightOAuth = waitForInflightOAuth;\n    }\n    getTokenStore() {\n        if (!this.tokenStore) {\n            throw new AuthError({\n                name: 'EmptyTokenStoreException',\n                message: 'TokenStore not set',\n            });\n        }\n        return this.tokenStore;\n    }\n    getTokenRefresher() {\n        if (!this.tokenRefresher) {\n            throw new AuthError({\n                name: 'EmptyTokenRefresherException',\n                message: 'TokenRefresher not set',\n            });\n        }\n        return this.tokenRefresher;\n    }\n    async getTokens(options) {\n        let tokens;\n        try {\n            assertTokenProviderConfig(this.authConfig?.Cognito);\n        }\n        catch (_err) {\n            // Token provider not configured\n            return null;\n        }\n        await this.waitForInflightOAuth();\n        tokens = await this.getTokenStore().loadTokens();\n        const username = await this.getTokenStore().getLastAuthUser();\n        if (tokens === null) {\n            return null;\n        }\n        const idTokenExpired = !!tokens?.idToken &&\n            isTokenExpired({\n                expiresAt: (tokens.idToken?.payload?.exp ?? 0) * 1000,\n                clockDrift: tokens.clockDrift ?? 0,\n            });\n        const accessTokenExpired = isTokenExpired({\n            expiresAt: (tokens.accessToken?.payload?.exp ?? 0) * 1000,\n            clockDrift: tokens.clockDrift ?? 0,\n        });\n        if (options?.forceRefresh || idTokenExpired || accessTokenExpired) {\n            tokens = await this.refreshTokens({\n                tokens,\n                username,\n            });\n            if (tokens === null) {\n                return null;\n            }\n        }\n        return {\n            accessToken: tokens?.accessToken,\n            idToken: tokens?.idToken,\n            signInDetails: tokens?.signInDetails,\n        };\n    }\n    async refreshTokens({ tokens, username, }) {\n        try {\n            const newTokens = await this.getTokenRefresher()({\n                tokens,\n                authConfig: this.authConfig,\n                username,\n            });\n            await this.setTokens({ tokens: newTokens });\n            Hub.dispatch('auth', { event: 'tokenRefresh' }, 'Auth', AMPLIFY_SYMBOL);\n            return newTokens;\n        }\n        catch (err) {\n            return this.handleErrors(err);\n        }\n    }\n    handleErrors(err) {\n        assertServiceError(err);\n        if (err.message !== 'Network error') {\n            // TODO(v6): Check errors on client\n            this.clearTokens();\n        }\n        if (err.name.startsWith('NotAuthorizedException')) {\n            return null;\n        }\n        else {\n            Hub.dispatch('auth', { event: 'tokenRefresh_failure' }, 'Auth', AMPLIFY_SYMBOL);\n            throw err;\n        }\n    }\n    async setTokens({ tokens }) {\n        return this.getTokenStore().storeTokens(tokens);\n    }\n    async clearTokens() {\n        return this.getTokenStore().clearTokens();\n    }\n    getDeviceMetadata(username) {\n        return this.getTokenStore().getDeviceMetadata(username);\n    }\n    clearDeviceMetadata(username) {\n        return this.getTokenStore().clearDeviceMetadata(username);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}